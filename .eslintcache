[{"/Users/filipmertens/code/boxtest/src/index.tsx":"1","/Users/filipmertens/code/boxtest/src/reportWebVitals.ts":"2","/Users/filipmertens/code/boxtest/src/App.tsx":"3","/Users/filipmertens/code/boxtest/src/components/Wallet/WalletService.ts":"4","/Users/filipmertens/code/boxtest/src/components/IPFS/IPFSService.ts":"5","/Users/filipmertens/code/boxtest/src/components/Remix/Client.ts":"6","/Users/filipmertens/code/boxtest/src/components/Files/FileService.ts":"7","/Users/filipmertens/code/boxtest/src/components/git/gitService.ts":"8","/Users/filipmertens/code/boxtest/src/components/3box/3boxService.ts":"9","/Users/filipmertens/code/boxtest/src/components/Files/utils.ts":"10","/Users/filipmertens/code/boxtest/src/components/Files/FileTools.tsx":"11","/Users/filipmertens/code/boxtest/src/components/Files/FileExplorer.tsx":"12","/Users/filipmertens/code/boxtest/src/components/IPFS/IPFSView.tsx":"13","/Users/filipmertens/code/boxtest/src/components/git/gitControls.tsx":"14","/Users/filipmertens/code/boxtest/src/components/git/Diff.tsx":"15","/Users/filipmertens/code/boxtest/src/components/git/gitLog.tsx":"16","/Users/filipmertens/code/boxtest/src/components/git/gitBranch.tsx":"17","/Users/filipmertens/code/boxtest/src/components/Files/Buttons.tsx":"18","/Users/filipmertens/code/boxtest/src/components/Files/statuses.tsx":"19","/Users/filipmertens/code/boxtest/src/components/Wallet/WalletView.tsx":"20","/Users/filipmertens/code/boxtest/src/components/3box/Box.tsx":"21"},{"size":500,"mtime":1607789583666,"results":"22","hashOfConfig":"23"},{"size":425,"mtime":1607789583667,"results":"24","hashOfConfig":"23"},{"size":3443,"mtime":1607793872409,"results":"25","hashOfConfig":"23"},{"size":1293,"mtime":1607792561504,"results":"26","hashOfConfig":"23"},{"size":3251,"mtime":1607792561502,"results":"27","hashOfConfig":"23"},{"size":2237,"mtime":1607792561503,"results":"28","hashOfConfig":"23"},{"size":6319,"mtime":1607792561497,"results":"29","hashOfConfig":"23"},{"size":8871,"mtime":1607792561508,"results":"30","hashOfConfig":"23"},{"size":2847,"mtime":1607794552680,"results":"31","hashOfConfig":"23"},{"size":2997,"mtime":1607792561500,"results":"32","hashOfConfig":"23"},{"size":335,"mtime":1607792561498,"results":"33","hashOfConfig":"23"},{"size":1892,"mtime":1607792561497,"results":"34","hashOfConfig":"23"},{"size":167,"mtime":1607792561502,"results":"35","hashOfConfig":"23"},{"size":1096,"mtime":1607792561507,"results":"36","hashOfConfig":"23"},{"size":919,"mtime":1607792561506,"results":"37","hashOfConfig":"23"},{"size":1716,"mtime":1607792561508,"results":"38","hashOfConfig":"23"},{"size":1829,"mtime":1607792561507,"results":"39","hashOfConfig":"23"},{"size":1175,"mtime":1607792561496,"results":"40","hashOfConfig":"23"},{"size":397,"mtime":1607792561499,"results":"41","hashOfConfig":"23"},{"size":918,"mtime":1607792561505,"results":"42","hashOfConfig":"23"},{"size":1749,"mtime":1607794709122,"results":"43","hashOfConfig":"23"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},"131wf7i",{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"46"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"46"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"46"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"46"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65","usedDeprecatedRules":"46"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"46"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"75","messages":"76","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"77","messages":"78","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"79","messages":"80","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"81","messages":"82","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"83","messages":"84","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"85","messages":"86","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/filipmertens/code/boxtest/src/index.tsx",[],["93","94"],"/Users/filipmertens/code/boxtest/src/reportWebVitals.ts",[],"/Users/filipmertens/code/boxtest/src/App.tsx",["95","96"],"/Users/filipmertens/code/boxtest/src/components/Wallet/WalletService.ts",["97"],"import WalletConnectProvider from \"@walletconnect/web3-provider\";\nimport Web3Modal from \"web3modal\";\nimport { getAddress } from \"@ethersproject/address\";\nimport Web3 from \"web3\";\nimport { BehaviorSubject } from \"rxjs\";\nexport class WalletService {\n  // WEB3 modal functions\n  web3Modal: Web3Modal = new Web3Modal();\n  addressBehavior = new BehaviorSubject<string>(\"\");\n  provider: any = \"\";\n  status = new BehaviorSubject<boolean>(false);\n  address: string = \"\";\n\n  async openModal() {\n    //if (!this.web3Modal) {\n    this.web3Modal = new Web3Modal({\n      providerOptions: this.getProviderOptions(), // required\n    });\n    this.web3Modal.on('connect', async (provider) => {\n        this.provider = provider\n//        const web3 = new Web3(this.provider);\n//        console.log(web3, this.provider);\n        const [address] = await this.provider.enable();\n        this.address = getAddress(address);\n        this.addressBehavior.next(getAddress(address));\n        this.status.next(true);\n    })\n    await this.web3Modal.connect();\n\n  }\n\n  getProviderOptions() {\n    const providerOptions = {\n      walletconnect: {\n        package: WalletConnectProvider,\n        options: {\n          infuraId: \"83d4d660ce3546299cbe048ed95b6fad\",\n        },\n      },\n    };\n    return providerOptions;\n  }\n}\n","/Users/filipmertens/code/boxtest/src/components/IPFS/IPFSService.ts",["98"],"import IpfsHttpClient from \"ipfs-http-client\";\nimport { toast } from \"react-toastify\";\nimport { fileservice, fs, gitservice } from \"../../App\";\n\nexport interface ipfsConfig {\n  host: string;\n  port: number;\n  protocol: string;\n  ipfsurl?: string;\n}\n\nexport interface ipfsFileObject {\n  path: string;\n  content: string;\n}\n\nconst ipfsurl = \"https://ipfs.io/ipfs/\";\nexport class IPFSService {\n  ipfsconfig: ipfsConfig = {\n    host: \"localhost\",\n    port: 5001,\n    protocol: \"http\",\n    ipfsurl: \"https://ipfs.io/ipfs/\",\n  };\n\n  ipfs = IpfsHttpClient(this.ipfsconfig);\n  filesToSend: ipfsFileObject[] = [];\n  cid: string = \"\";\n\n  async getipfsurl() {\n    //return $(\"#IPFS-url\").val() != \"\" ? $(\"#IPFS-url\").val() : false || ipfsurl;\n  }\n\n  showspinner() {}\n\n  hidespinner() {}\n\n  async setipfsHost() {\n    this.ipfs = IpfsHttpClient(this.ipfsconfig);\n    try {\n      await this.ipfs.config.getAll();\n\n      return true;\n    } catch (e) {\n      console.log(\"IPFS error\", e);\n\n      toast.error(\n        \"There was an error connecting to IPFS, please check your IPFS settings if applicable.\"\n      );\n\n      this.hidespinner();\n      return false;\n    }\n  }\n\n  async addToIpfs() {\n    this.showspinner();\n    this.filesToSend = [];\n    // first get files in current commit, not the files in the FS because they can be changed or unstaged\n\n    let filescommited;\n    try {\n      filescommited = await gitservice.listFiles();\n    } catch (e) {\n      toast.warning(\"No files commited\");\n      this.hidespinner();\n      return false;\n    }\n    const currentcommitoid = await gitservice.getCommitFromRef(\"HEAD\");\n    for (let i = 0; i < filescommited.length; i++) {\n      const ob: ipfsFileObject = {\n        path: filescommited[i],\n        content: await gitservice.getFileContentCommit(\n          filescommited[i],\n          currentcommitoid\n        ),\n      };\n      this.filesToSend.push(ob);\n    }\n    console.log(this.filesToSend);\n    //return true;\n\n    // then we get the git objects folder\n    const files = await fileservice.getDirectory(\"/.git\");\n    console.log(\"files to send\", files, files.length);\n\n    for (let i = 0; i < files.length; i++) {\n      const fi = files[i];\n      console.log(\"fetching \", fi);\n      const ob = {\n        path: fi,\n        content: await fs.readFile(fi),\n      };\n      this.filesToSend.push(ob);\n    }\n\n    let connected = await this.setipfsHost();\n    if (!connected) return false;\n\n    const addOptions = {\n      wrapWithDirectory: true,\n    };\n    try {\n      await this.ipfs.add(this.filesToSend, addOptions).then((x) => {\n        console.log(x.cid.string);\n        /* $('#CID').attr('href', `${ipfsurl}${x.cid.string}`)\n            $('#CID').html(`Your files are here: ${x.cid.string}`) */\n        this.cid = x.cid.string;\n      });\n      toast.success(\n        `You files were uploaded to IPFS: <a target=_blank href=\"${await this.getipfsurl()}${\n          this.cid\n        }\">${this.cid}</a>`\n      );\n      this.hidespinner();\n    } catch (e) {\n      toast.error(\n        \"There was an error uploading to IPFS, please check your IPFS settings if applicable.\"\n      );\n      toast.error(\"There was an error uploading to IPFS!\");\n      this.hidespinner();\n      console.log(e);\n    }\n\n    return true;\n  }\n}\n","/Users/filipmertens/code/boxtest/src/components/Remix/Client.ts",["99"],"import { PluginClient } from '@remixproject/plugin'\nimport { createClient } from '@remixproject/plugin-webview'\nimport { toast } from 'react-toastify'\nimport { BehaviorSubject } from 'rxjs'\nimport { gitservice } from '../../App'\nimport { fileservice } from '../../App'\n\n\nexport class WorkSpacePlugin extends PluginClient {\n    clientLoaded = new BehaviorSubject(false)\n    callBackEnabled:boolean = true\n\n    constructor() {\n        super()\n        createClient(this)\n        toast.info(\"Connecting to REMIX\")\n        this.onload().then(async () => {\n            console.log('workspace client loaded', this)\n            toast.success(\"Connected to REMIX\")\n            this.clientLoaded.next(true)\n            await this.enableCallBacks()\n        })\n    }\n\n    async enableCallBacks() {\n        this.on('solidity','compilationFinished', async(file, source,version,result) =>{\n            console.log(\"compilationFinished\")\n            console.log(result.contracts);\n            const r = await this.call('solidity','getCompilationResult')\n            console.log(\"getCompilationResult\")\n            console.log(r.contracts)\n\n        })\n\n        this.on('fileManager', 'currentFileChanged', async (e) => {\n          // Do something\n          console.log(e)\n          fileservice.addFileFromBrowser(e)\n       \n          //await this.addFileFromBrowser(e)\n        })\n    \n        this.on('fileManager', 'currentFileChanged', async (e) => {\n          // Do something\n          fileservice.addFileFromBrowser(e)\n          console.log(e)\n        })\n    \n        this.on('fileManager', 'currentFileChanged', async (e) => {\n          // Do something\n          console.log(e)\n         // await this.rmFile(e)\n    \n        })\n    \n        this.on('fileManager', 'currentFileChanged', async (e) => {\n          // Do something\n          console.log(e)\n          //await this.rmFile(e)\n        })\n    \n        this.on('fileManager', 'currentFileChanged', async (e) => {\n          // Do something\n          console.log(e)\n          fileservice.addFileFromBrowser(e)\n          //await this.addFileFromBrowser(e)\n        })\n        this.callBackEnabled = true\n      }\n    \n      async disableCallBacks() {\n        this.callBackEnabled = false\n      }\n}\n\n","/Users/filipmertens/code/boxtest/src/components/Files/FileService.ts",["100","101","102"],"import { toast } from \"react-toastify\";\nimport { gitservice } from \"../../App\";\nimport { client } from \"../../App\";\nimport path from \"path\";\nimport { fs } from \"../../App\";\nimport { removeSlash, jsonObjectFromFileList } from \"./utils\";\nimport { BehaviorSubject } from \"rxjs\";\nimport {\n  fileExplorerNode,\n  fileStatusResult,\n  statusMatrix,\n} from \"./types\";\n\nexport const fileStatuses = [\n  [\"new, untracked\", 0, 2, 0], // new, untracked\n  [\"added, staged\", 0, 2, 2], //\n  [\"added, staged, with unstaged changes\", 0, 2, 3], // added, staged, with unstaged changes\n  [\"unmodified\", 1, 1, 1], // unmodified\n  [\"modified, unstaged\", 1, 2, 1], // modified, unstaged\n  [\"modified, staged\", 1, 2, 2], // modified, staged\n  [\"modified, staged, with unstaged changes\", 1, 2, 3], // modified, staged, with unstaged changes\n  [\"deleted, unstaged\", 1, 0, 1], // deleted, unstaged\n  [\"deleted, staged\", 1, 0, 0], // deleted, staged\n];\n\nconst statusmatrix: statusMatrix[] = fileStatuses.map((x: any) => {\n  return {\n    matrix: x.shift().split(\",\"),\n    status: x,\n  };\n});\nconsole.log(\"matrix\", statusmatrix);\n\nexport class LsFileService {\n  filetreecontent = new BehaviorSubject<fileExplorerNode>({ children: [] });\n  fileStatusResult: fileStatusResult[] = []\n\n  async addFileFromBrowser(file: string) {\n    if (!client.callBackEnabled) return false;\n    const content = await client.call(\"fileManager\", \"readFile\", file);\n    console.log(content);\n    await this.addFile(file, content);\n    //return content\n  }\n\n  async clearDb() {\n    const req = indexedDB.deleteDatabase(\"remix-workspace\");\n\n    let me = this;\n    req.onsuccess = async function () {\n      toast(\"Deleted database successfully\");\n      //await me.gitlog()\n      await me.showFiles();\n      await gitservice.init();\n    };\n  }\n\n  async syncToBrowser() {\n    //this.showspinner();\n    await client.disableCallBacks();\n    let filesToSync = [];\n    // first get files in current commit, not the files in the FS because they can be changed or unstaged\n\n    let filescommited = await gitservice.listFiles();\n    const currentcommitoid = await gitservice.getCommitFromRef(\"HEAD\");\n    for (let i = 0; i < filescommited.length; i++) {\n      const ob = {\n        path: filescommited[i],\n        content: await gitservice.getFileContentCommit(\n          filescommited[i],\n          currentcommitoid\n        ),\n      };\n      console.log(\"sync file\", ob);\n      try {\n        await client.call(\"fileManager\", \"setFile\", ob.path, ob.content);\n      } catch (e) {\n        console.log(\"could not load file\", e);\n        //this.hidespinner();\n      }\n      filesToSync.push(ob);\n    }\n    console.log(\"files to sync\", filesToSync);\n\n    await this.showFiles();\n    await client.enableCallBacks();\n    toast(\"Import successfull\");\n    //this.hidespinner();\n  }\n\n  async addFile(file: string, content: string) {\n    console.log(\"add file \", file);\n    const directories = path.dirname(file);\n    await this.createDirectoriesFromString(directories);\n    console.log(fs);\n    await fs.writeFile(\"/\" + file, content);\n    await this.showFiles();\n  }\n\n  async rmFile(file: string) {\n    console.log(\"rm file \", file);\n    await fs.unlink(\"/\" + file);\n    await this.showFiles();\n  }\n\n  async createDirectoriesFromString(strdirectories: string) {\n    const ignore = [\".\", \"/.\", \"\"];\n    console.log(\"directory\", strdirectories, ignore.indexOf(strdirectories));\n    if (ignore.indexOf(strdirectories) > -1) return false;\n    let directories: string[] = strdirectories.split(\"/\");\n    console.log(\"create directory\", directories);\n    for (let i = 0; i < directories.length; i++) {\n      console.log(directories[i]);\n      let previouspath = \"\";\n      if (i > 0) previouspath = \"/\" + directories.slice(0, i).join(\"/\");\n      const finalPath = previouspath + \"/\" + directories[i];\n      console.log(\"creating \", finalPath);\n      try {\n        await fs.mkdir(finalPath);\n      } catch (e) {\n        // console.log(e)\n      }\n    }\n  }\n\n  async viewFile(args: any) {\n    const filename = args; \n    console.log(\"view file\",filename)\n    //$(args[0].currentTarget).data('file')\n    try{\n      await client.call(\"fileManager\", \"switchFile\", `${removeSlash(filename)}`);\n    }catch(e){\n      toast.error(\"file does not exist in Remix\")\n    }\n  }\n\n  async getFileStatusMatrix() {\n    this.fileStatusResult = await gitservice.statusMatrix();\n    this.fileStatusResult.map((m) => {\n      statusmatrix.map((sm) => {\n        if (JSON.stringify(sm.status) === JSON.stringify(m.status)) {\n          console.log(m, sm);\n          m.statusNames = sm.matrix;\n        }\n      });\n    });\n    console.log(\"file status\", this.fileStatusResult);\n  }\n\n  getFileStatusForFile(filename:string){\n    console.log(\"checking file status\",filename)\n    for(let i:number=0;i<this.fileStatusResult.length;i++){\n      if(this.fileStatusResult[i].filename == filename) return this.fileStatusResult[i].statusNames\n    }\n  }\n\n  async showFiles() {\n    //$('#files').show()\n    //$('#diff-container').hide()\n    let files = await this.getDirectory(\"/\");\n    console.log(\"get directory result\", files);\n\n    try {\n      await this.getFileStatusMatrix();\n      let jsonfiles = await jsonObjectFromFileList(files);\n      console.log(\"files\", jsonfiles);\n      this.filetreecontent.next(jsonfiles);\n    } catch (e) {}\n\n    try {\n      await gitservice.gitlog();\n    } catch (e) {}\n    try {\n      await gitservice.getBranches();\n    } catch (e) {}\n    await gitservice.diffFiles()\n    return true;\n  }\n\n  async getDirectory(dir: string) {\n    //console.log('get directory')\n    let result: string[] = [];\n    const files = await fs.readdir(`${dir}`);\n    //console.log('readdir', files)\n    // await files.map(async (fi)=>{\n    for (let i = 0; i < files.length; i++) {\n      const fi = files[i];\n      if (typeof fi !== \"undefined\") {\n        // console.log('looking into ', fi, dir)\n        if (dir === \"/\") dir = \"\";\n        const type = await fs.stat(`${dir}/${fi}`);\n        if (type.type === \"dir\") {\n          // console.log('is directory, so get ', `${dir}/${fi}`)\n          result = [...result, ...(await this.getDirectory(`${dir}/${fi}`))];\n        } else {\n          // console.log('is file ', `${dir}/${fi}`)\n          result.push(`${dir}/${fi}`);\n        }\n      }\n    }\n\n    // })\n    return result;\n  }\n}\n","/Users/filipmertens/code/boxtest/src/components/git/gitService.ts",["103"],"import git, { ReadCommitResult } from \"isomorphic-git\";\nimport { fileservice, fs, fsNoPromise } from \"../../App\";\nimport { toast } from \"react-toastify\";\nimport path from \"path\";\nimport { removeSlash } from \"../Files/utils\";\nimport { BehaviorSubject } from \"rxjs\";\n\nexport interface diffObject {\n  originalFileName: string;\n  updatedFileName: string;\n  past: string;\n  current: string;\n}\nexport class gitService {\n  commits = new BehaviorSubject<ReadCommitResult[] | undefined>(undefined);\n  branch = new BehaviorSubject<string>(\"\");\n  branches = new BehaviorSubject<string[] | undefined>(undefined);\n  diffResult = new BehaviorSubject<diffObject[] | undefined>(undefined);\n\n  constructor() {\n    this.init();\n  }\n\n  async init() {\n    await git.init({\n      fs: fsNoPromise,\n      dir: \"/\",\n      defaultBranch: \"master\",\n    });\n    toast.info(`Git version ${git.version()}`);\n\n    fileservice.showFiles();\n  }\n\n  async addToGit(args: string | undefined) {\n    if (args !== undefined) {\n      //console.log('ADD TO GIT', $(args[0].currentTarget).data('file'))\n      const filename = args; // $(args[0].currentTarget).data('file')\n      const basename = path.basename(filename);\n      const directory = path.dirname(filename);\n      console.log(\"will add\", basename, directory);\n\n      await git.add({\n        fs: fsNoPromise,\n        dir: \"/\",\n        filepath: removeSlash(filename),\n      });\n      await fileservice.showFiles();\n      toast.success(`Added file ${filename}`);\n    }\n  }\n\n  async gitrm(args: any) {\n    //console.log('RM GIT', $(args[0].currentTarget).data('file'))\n    const filename = args; // $(args[0].currentTarget).data('file')\n\n    await git.remove({\n      fs: fsNoPromise,\n      dir: \"/\",\n      filepath: removeSlash(filename),\n    });\n    await fileservice.showFiles();\n    toast.success(`Removed file file ${filename}`);\n  }\n\n  async checkoutfile(args: any) {\n    const filename = \"\"; //$(args[0].currentTarget).data('file')\n    console.log(\"checkout\", filename);\n\n    try {\n      await git.checkout({\n        fs: fsNoPromise,\n        dir: \"/\",\n        ref: \"HEAD\",\n        filepaths: [`/${filename}`],\n      });\n    } catch (e) {\n      console.log(e);\n      //this.addAlert(\"checkoutMessage\", e)\n    }\n    console.log(\"done\");\n    //await this.syncToBrowser();\n  }\n\n  async checkout(args: string) {\n    const oid = args; //$(args[0].currentTarget).data('oid')\n    console.log(\"checkout\", oid);\n\n    try {\n      await git.checkout({\n        fs: fsNoPromise,\n        dir: \"/\",\n        ref: oid,\n      });\n\n      this.gitlog();\n    } catch (e) {\n      console.log(e);\n      toast.error(\" \" + e);\n    }\n\n    console.log(\"done\");\n    //await this.syncToBrowser();\n  }\n\n  async getCommits() {\n    console.log(\"get commits\");\n    try {\n      const commits: ReadCommitResult[] = await git.log({\n        fs: fsNoPromise,\n        dir: \"/\",\n        depth: 200,\n      });\n      return commits;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async gitlog() {\n    console.log(\"log\");\n\n    //$('#status').empty()\n    // console.log(fs);\n\n    try {\n      const commits: ReadCommitResult[] = await this.getCommits();\n      this.commits.next(commits);\n      console.log(commits);\n      /*\n      const template = require(\"./commits.html\");\n      const html = template.render({\n        commits: commits,\n      });\n      */\n      //$('#status').html(html)\n    } catch (e) {\n      console.log(e);\n      //$('#status').html('Log is empty')\n    }\n\n    await this.showCurrentBranch();\n  }\n\n  async createBranch(name: string = \"\") {\n    const branch = name; //|| $(\"#newbranchname\").val();\n    if (branch)\n      await git.branch({\n        fs: fsNoPromise,\n        dir: \"/\",\n        ref: branch,\n      });\n\n    fileservice.showFiles();\n  }\n\n  async showCurrentBranch() {\n    //$('#init-btn').hide()\n    //$('.gitIsReady').show()\n\n    try {\n      const branch = await this.currentBranch();\n      this.branch.next(branch);\n      if (typeof branch === \"undefined\" || branch === \"\") {\n        toast.warn(`You are in a detached state`);\n        this.branch.next(`You are in a detached state`);\n      } else {\n        const currentcommitoid = await this.getCommitFromRef(branch);\n        this.branch.next(`Branch is: ${branch} at commit ${currentcommitoid}`);\n      }\n    } catch (e) {\n      // this means git is not init\n      //console.log(e)\n      //$('#init-btn').show()\n      //$('.gitIsReady').hide()\n      //toast(\"There is no active branch. Add and commit files.\");\n      //await this.createBranch()\n      //toast('No active branch')\n    }\n  }\n\n  async getLastCommmit() {\n    try {\n      let currentcommitoid = \"\";\n      const branch = await this.currentBranch();\n      if (typeof branch !== \"undefined\") {\n        currentcommitoid = await this.getCommitFromRef(branch);\n        return currentcommitoid;\n      }\n    } catch (e) {\n      return false;\n    }\n  }\n\n  async currentBranch() {\n    ///$('#branch').empty()\n\n    try {\n      const branch: string =\n        (await git.currentBranch({\n          fs: fsNoPromise,\n          dir: \"/\",\n          fullname: false,\n        })) || \"\";\n      console.log(\"BRANCH\", branch);\n      return branch;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async commit(message: string = \"\") {\n    const sha = await git.commit({\n      fs: fsNoPromise,\n      dir: \"/\",\n      author: {\n        name: \"Remix Workspace\",\n        email: \"\",\n      },\n      message: message, //$('#message').val()\n    });\n    toast.success(`commited ${sha}`);\n    await fileservice.showFiles();\n  }\n\n  async getBranches() {\n    let branches: string[] = await git.listBranches({\n      fs: fsNoPromise,\n      dir: \"/\",\n    });\n    this.branches.next(branches);\n  }\n\n  async getCommitFromRef(ref: string) {\n    const commitOid = await git.resolveRef({\n      fs: fsNoPromise,\n      dir: \"/\",\n      ref: ref,\n    });\n    return commitOid;\n  }\n\n  async getFileContentCommit(fullfilename: string, commitOid: string) {\n    let content = \"\";\n    try {\n      const { blob } = await git.readBlob({\n        fs: fsNoPromise,\n        dir: \"/\",\n        oid: commitOid,\n        filepath: removeSlash(fullfilename),\n      });\n      content = Buffer.from(blob).toString(\"utf8\");\n    } catch (e) {\n      console.log(e);\n    }\n    return content;\n  }\n\n  async statusMatrix(dir: string = \"/\", ref: string = \"HEAD\") {\n    const matrix = await git\n      .statusMatrix({\n        fs: fsNoPromise,\n        dir: \"/\",\n      })\n      .catch((e) => {});\n\n    let result = (matrix || []).map((x) => {\n      return {\n        filename: `/${x.shift()}`,\n        status: x,\n      };\n    });\n    return result;\n  }\n\n  async listFiles(dir: string = \"/\", ref: string = \"HEAD\") {\n    let filescommited = await git.listFiles({\n      fs: fsNoPromise,\n      dir: dir,\n      ref: ref,\n    });\n    return filescommited;\n  }\n\n  async addAll() {\n    const statuses = fileservice.fileStatusResult;\n    console.log(statuses);\n\n    for (let i: number = 0; i < statuses.length; i++) {\n      await this.addToGit(statuses[i].filename);\n    }\n  }\n\n  async diffFiles() {\n    const statuses = fileservice.fileStatusResult;\n    console.log(statuses);\n    const diffs: diffObject[] = [];\n    for (let i: number = 0; i < statuses.length; i++) {\n      if ((statuses[i].statusNames?.indexOf(\"modified\") || false) > -1) {\n        console.log(statuses[i].statusNames?.indexOf(\"modified\"));\n        const diff: diffObject = await this.diffFile(statuses[i].filename);\n        diffs.push(diff);\n      }\n    }\n    this.diffResult.next(diffs);\n  }\n\n  async diffFile(args: any) {\n    //$('#files').hide()\n    //$('#diff-container').show()\n\n    const fullfilename = args; // $(args[0].currentTarget).data('file')\n    const filename = \"\"; // path.basename($(args[0].currentTarget).data('file'))\n    const commitOid = await git.resolveRef({\n      fs: fsNoPromise,\n      dir: \"/\",\n      ref: \"HEAD\",\n    });\n\n    try {\n      const { blob } = await git.readBlob({\n        fs: fsNoPromise,\n        dir: \"/\",\n        oid: commitOid,\n        filepath: removeSlash(fullfilename),\n      });\n\n      const newcontent = await fs.readFile(fullfilename, {\n        encoding: \"utf8\",\n      });\n      const original = Buffer.from(blob).toString(\"utf8\");\n\n      console.log(original);\n      console.log(newcontent);\n      //const filediff = createPatch(filename, original, newcontent); // diffLines(original,newcontent)\n      //console.log(filediff)\n      const filediff: diffObject = {\n        originalFileName: fullfilename,\n        updatedFileName: fullfilename,\n        current: newcontent,\n        past: original,\n      };\n\n      return filediff;\n    } catch (e) {\n      toast(\"Nothing to diff!\");\n\n      const filediff: diffObject = {\n        originalFileName: \"\",\n        updatedFileName: \"\",\n        current: \"\",\n        past: \"\",\n      };\n      return filediff;\n      //$('#files').show()\n      //$('#diff-container').hide()\n    }\n  }\n}\n","/Users/filipmertens/code/boxtest/src/components/3box/3boxService.ts",[],"/Users/filipmertens/code/boxtest/src/components/Files/utils.ts",["104","105","106"],"import path from \"path\";\nimport { fileExplorerNode } from \"./types\";\n\nexport const removeSlash = (s: string) => {\n  return s.replace(/^\\/+/, \"\");\n};\n\nexport const jsonObjectFromFileList = (files: string[]) => {\n  const ob: fileExplorerNode[] = [];\n  // reindex filelist\n  files.map((f, i) => {\n    const dirname = path.dirname(files[i]);\n    if (dirname.startsWith(\"/.\")) return true;\n    const basename = path.basename(files[i]);\n    const directories = removeSlash(dirname).split(\"/\");\n    let node: fileExplorerNode;\n    if (\n      !ob.find((x) => {\n        return x.fullname === dirname;\n      })\n    ) {\n      node = {\n        type: \"dir\",\n        dir: true,\n        file: false,\n        name: directories.pop(),\n        fullname: dirname,\n        parentDir: path.dirname(dirname),\n      };\n      ob.push(node);\n    }\n\n    let previouspath = \"\";\n    for (let i = 0; i < directories.length; i++) {\n      if (i > 0) previouspath = \"/\" + directories.slice(0, i).join(\"/\");\n      const finalPath = previouspath + \"/\" + directories[i];\n      if (\n        !ob.find((x) => {\n          return x.fullname === finalPath;\n        })\n      ) {\n        node = {\n          type: \"dir\",\n          dir: true,\n          file: false,\n          name: directories[i],\n          fullname: finalPath,\n          parentDir: path.dirname(finalPath),\n        };\n        ob.push(node);\n      }\n    }\n    if (\n      !ob.find((x) => {\n        return x.fullname === files[i];\n      })\n    ) {\n      node = {\n        type: \"file\",\n        file: true,\n        dir: false,\n        name: basename,\n        fullname: files[i],\n        directory: dirname,\n        status: [],\n      };\n      ob.push(node);\n    }\n  });\n  // asign ids\n  ob.map((f, i) => {\n    f.id = i;\n  });\n  // find parents\n  ob.map((f, i) => {\n    f.parentId = null;\n    f.children = null;\n    if (f.type === \"file\") {\n      // f.parent\n\n      const parent = ob.find((x) => {\n        return x.fullname === f.directory && x.type === \"dir\";\n      });\n      f.parentId = parent ? parent.id : null;\n    } else {\n      //console.log(f)\n      const parent = ob.find((x) => {\n        return x.fullname === f.parentDir && x.type === \"dir\";\n      });\n      f.parentId = parent ? parent.id : null;\n    }\n  });\n  console.log(\"build tree from\", ob.sort(sortbydirectorylevel));\n  // first we need it sorted\n  const nest = (items: any, id = null, link = \"parentId\") =>\n    items\n      .filter((item: any) => item[link] === id)\n      .map((item: any) => ({\n        ...item,\n        children: nest(items, item.id),\n      }));\n\n  console.log(\"build tree from\", ob);\n\n  let t: fileExplorerNode[] = nest(ob);\n\n  let result: fileExplorerNode = {\n    children: t,\n  };\n  // console.log('OB', ob)\n  return result;\n};\n\nconst sortbydirectorylevel = (a: any, b: any) => {\n  //console.log(a,b);\n  if (a.fullname.split(\"/\").length < b.fullname.split(\"/\").length) {\n    return -1;\n  }\n  if (a.fullname.split(\"/\").length > b.fullname.split(\"/\").length) {\n    return 1;\n  }\n  return 0;\n};\n","/Users/filipmertens/code/boxtest/src/components/Files/FileTools.tsx",["107"],"/Users/filipmertens/code/boxtest/src/components/Files/FileExplorer.tsx",[],"/Users/filipmertens/code/boxtest/src/components/IPFS/IPFSView.tsx",["108"],"/Users/filipmertens/code/boxtest/src/components/git/gitControls.tsx",["109"],"/Users/filipmertens/code/boxtest/src/components/git/Diff.tsx",["110","111","112","113"],"/Users/filipmertens/code/boxtest/src/components/git/gitLog.tsx",["114"],"/Users/filipmertens/code/boxtest/src/components/git/gitBranch.tsx",["115"],"/Users/filipmertens/code/boxtest/src/components/Files/Buttons.tsx",["116","117"],"/Users/filipmertens/code/boxtest/src/components/Files/statuses.tsx",[],"/Users/filipmertens/code/boxtest/src/components/Wallet/WalletView.tsx",["118"],"/Users/filipmertens/code/boxtest/src/components/3box/Box.tsx",[],{"ruleId":"119","replacedBy":"120"},{"ruleId":"121","replacedBy":"122"},{"ruleId":"123","severity":1,"message":"124","line":2,"column":8,"nodeType":"125","messageId":"126","endLine":2,"endColumn":12},{"ruleId":"123","severity":1,"message":"127","line":19,"column":10,"nodeType":"125","messageId":"126","endLine":19,"endColumn":20},{"ruleId":"123","severity":1,"message":"128","line":4,"column":8,"nodeType":"125","messageId":"126","endLine":4,"endColumn":12},{"ruleId":"123","severity":1,"message":"129","line":17,"column":7,"nodeType":"125","messageId":"126","endLine":17,"endColumn":14},{"ruleId":"123","severity":1,"message":"130","line":5,"column":10,"nodeType":"125","messageId":"126","endLine":5,"endColumn":20},{"ruleId":"131","severity":1,"message":"132","line":139,"column":35,"nodeType":"133","messageId":"134","endLine":139,"endColumn":37},{"ruleId":"131","severity":1,"message":"132","line":140,"column":29,"nodeType":"133","messageId":"134","endLine":140,"endColumn":31},{"ruleId":"135","severity":1,"message":"136","line":153,"column":44,"nodeType":"137","messageId":"138","endLine":153,"endColumn":46},{"ruleId":"123","severity":1,"message":"139","line":313,"column":11,"nodeType":"125","messageId":"126","endLine":313,"endColumn":19},{"ruleId":"131","severity":1,"message":"140","line":11,"column":20,"nodeType":"133","messageId":"141","endLine":11,"endColumn":22},{"ruleId":"131","severity":1,"message":"132","line":71,"column":17,"nodeType":"133","messageId":"134","endLine":71,"endColumn":19},{"ruleId":"131","severity":1,"message":"132","line":75,"column":17,"nodeType":"133","messageId":"134","endLine":75,"endColumn":19},{"ruleId":"142","severity":1,"message":"143","line":8,"column":53,"nodeType":"144","messageId":"138","endLine":8,"endColumn":55},{"ruleId":"142","severity":1,"message":"143","line":7,"column":51,"nodeType":"144","messageId":"138","endLine":7,"endColumn":53},{"ruleId":"142","severity":1,"message":"143","line":8,"column":53,"nodeType":"144","messageId":"138","endLine":8,"endColumn":55},{"ruleId":"123","severity":1,"message":"145","line":1,"column":17,"nodeType":"125","messageId":"126","endLine":1,"endColumn":26},{"ruleId":"142","severity":1,"message":"143","line":9,"column":47,"nodeType":"144","messageId":"138","endLine":9,"endColumn":49},{"ruleId":"123","severity":1,"message":"146","line":10,"column":10,"nodeType":"125","messageId":"126","endLine":10,"endColumn":14},{"ruleId":"123","severity":1,"message":"147","line":10,"column":16,"nodeType":"125","messageId":"126","endLine":10,"endColumn":23},{"ruleId":"142","severity":1,"message":"143","line":8,"column":47,"nodeType":"144","messageId":"138","endLine":8,"endColumn":49},{"ruleId":"142","severity":1,"message":"143","line":8,"column":53,"nodeType":"144","messageId":"138","endLine":8,"endColumn":55},{"ruleId":"123","severity":1,"message":"148","line":16,"column":9,"nodeType":"125","messageId":"126","endLine":16,"endColumn":17},{"ruleId":"135","severity":1,"message":"136","line":21,"column":16,"nodeType":"137","messageId":"138","endLine":21,"endColumn":18},{"ruleId":"142","severity":1,"message":"143","line":10,"column":53,"nodeType":"144","messageId":"138","endLine":10,"endColumn":55},"no-native-reassign",["149"],"no-negated-in-lhs",["150"],"@typescript-eslint/no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'WalletView' is defined but never used.","'Web3' is defined but never used.","'ipfsurl' is assigned a value but never used.","'gitservice' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'filename' is assigned a value but never used.","Array.prototype.map() expects a value to be returned at the end of arrow function.","expectedAtEnd","no-empty-pattern","Unexpected empty object pattern.","ObjectPattern","'useEffect' is defined but never used.","'mock' is assigned a value but never used.","'setMock' is assigned a value but never used.","'diffFile' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]